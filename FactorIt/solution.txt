# follow the steps given to obtain flag


$ file rsa_key
rsa_key: gzip compressed data, from Unix, original size modulo 2^32 10240

$ tar vxf rsa_key
rsa_key.7z

$ file rsa_key.7z
rsa_key.7z: 7-zip archive data, version 0.4

$ 7z x rsa_key.7z
7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21
p7zip Version 16.02 (locale=en_IN,Utf16=on,HugeFiles=on,64 bits,1 CPU Intel(R) Core(TM) i3-8145U CPU @ 2.10GHz (806EB),ASM,AES-NI)

Scanning the drive for archives:
1 file, 589 bytes (1 KiB)

Extracting archive: rsa_key.7z

Path = rsa_key.7z
Type = 7z
Physical Size = 589
Headers Size = 130
Method = LZMA2:12
Solid = -
Blocks = 1

Everything is Ok

Size:       455
Compressed: 589

$ file rsa-unzipped
rsa-unzipped: gzip compressed data, from Unix, original size modulo 2^32 10240

$ tar vxf rsa-unzipped
./RSA/
./RSA/flag.enc
./RSA/public.pem

$ cd RSA

$ openssl rsa -in public.pem -pubin -text -modulus
RSA Public-Key: (1024 bit)
Modulus:
    00:80:00:00:00:20:00:00:00:00:00:00:00:00:00:
    00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:
    00:00:00:00:00:00:00:00:00:00:00:08:00:00:00:
    02:00:08:00:00:00:02:00:00:00:00:00:00:08:00:
    00:00:00:01:0c:80:00:00:15:e0:00:00:00:00:00:
    00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:
    00:00:00:00:00:00:00:00:00:80:00:00:00:00:0b:
    d0:00:00:00:00:0b:50:00:00:00:00:00:00:00:00:
    00:05:78:00:00:00:00:7b:bb
Exponent: 65537 (0x10001)
Modulus=8000000020000000000000000000000000000000000000000000000000000000000000000000000008000000020008000000020000000000000800000000010C80000015E0000000000000000000000000000000000000000000000000000000000080000000000BD0000000000B500000000000000000000578000000007BBB
writing RSA key
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCAAAAAIAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIACAAAAAIAAAAAAAAIAAAAAAEMgAAA
FeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAC9AAAAAAC1AAAAAA
AAAAAAAFeAAAAAB7uwIDAQAB
-----END PUBLIC KEY-----

## this gives the modulus value:
8000000020000000000000000000000000000000000000000000000000000000000000000000000008000000020008000000020000000000000800000000010C80000015E0000000000000000000000000000000000000000000000000000000000080000000000BD0000000000B500000000000000000000578000000007BBB

# Factoring the public key
## open python terminal
$ python3
## binary value of modulus
>>> modulus=bin(0x8000000020000000000000000000000000000000000000000000000000000000000000000000000008000000020008000000020000000000000800000000010C80000015E0000000000000000000000000000000000000000000000000000000000080000000000BD0000000000B500000000000000000000578000000007BBB)
>>> print(modulus)
0b1000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000100000000000001000000000000000000000000000000000100000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000010000110010000000000000000000000000010101111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000001011110100000000000000000000000000000000000000001011010100000000000000000000000000000000000000000000000000000000000000000000000000000000010101111000000000000000000000000000000000000111101110111011
## thus it can be seen that the modulus contains a lot of zeroes.
## decimal value of modulus
>>> n=int('1000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000100000000000001000000000000000000000000000000000100000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000010000110010000000000000000000000000010101111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000001011110100000000000000000000000000000000000000001011010100000000000000000000000000000000000000000000000000000000000000000000000000000000010101111000000000000000000000000000000000000111101110111011', 2)
>>> print(n)
89884656748347771007491955442519718365762139037747188068870966396462775345965086308175215821815090849689022799485543499606961594936646727045581304747885103453134806715085115491265903907353233283931330998530240306995787378044213712562911808807497656903004670612588152642363425873221425508276222214009857801147
## using bit patterns to guess how the modulus was generated.
## for the math: check RSA in real world! challenge from ASIS Cyber SEcurity COntest Finals 2014
>>> A=0b10110101
>>> B=0b10101111
>>> a=51
>>> b=477
>>> c=511
>>> d=140
>>> e=188
>>> f=512
>>> p=(2**a + 2**b + 2**c + A)
>>> q=(2**d + 2**e + 2**f + B)
>>> print(p)
6703903965361517118576511528025622717463828698514771456694902115718276634989944955753407851598489976727952425488221391817052769267904281935379659980013749
>>> print(q)
13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903820008890319855427587165500997237443558735689450602365103
## checking if n is factorized into p and q correctly
>>> p*q==n
True
$ ./rsatool.py -p 6703903965361517118576511528025622717463828698514771456694902115718276634989944955753407851598489976727952425488221391817052769267904281935379659980013749 -q 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903820008890319855427587165500997237443558735689450602365103 -o private.pem
Using (p, q) to initialise RSA instance

n =
80000000200000000000000000000000000000000000000000000000000000000000000000000000
08000000020008000000020000000000000800000000010c80000015e00000000000000000000000
00000000000000000000000000000000000080000000000bd0000000000b50000000000000000000
0578000000007bbb

e = 65537 (0x10001)

d =
6a1e15e204a59b5a64a59b5a64a59b5a64a59b5a64a59b5a64a59b5a64a59b5a64a59b5a64a59b5a
6b477cb884effbb1ec4e155a64a59b5a64ac3d3bc2c43e191d85e28c25a29a5d65a29a5d65a29a5d
65a29a5d65a29a5d65a29a5d65a29a5d65a3047b7b848485394786b87950da5d65a29a5d65a29a5d
6a24a18b5e7506f9

p =
80000000200000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000080000000000b5

q =
10000000000000000000000000000000000000000000000000000000000000000000000000000000
01000000000001000000000000000000000000000000000af

Saving PEM as private.pem

# run solution.py
$ ./solution.py
b'fact0r1ngK3y5'




